<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCTV Stream Viewer - Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #0f1419;
            color: #e1e8ed;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #1d9bf0;
        }

        .controls {
            background-color: #1a2633;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        label {
            min-width: 120px;
            font-weight: 500;
        }

        input, select, button {
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid #2f3336;
            background-color: #0f1419;
            color: #e1e8ed;
            font-size: 14px;
        }

        input, select {
            flex: 1;
        }

        button {
            background-color: #1d9bf0;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
            min-width: 100px;
        }

            button:hover {
                background-color: #1a8cd8;
            }

            button:disabled {
                background-color: #536471;
                cursor: not-allowed;
            }

        .status {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: center;
        }

            .status.connected {
                background-color: #00ba7c;
                color: white;
            }

            .status.disconnected {
                background-color: #f91880;
                color: white;
            }

            .status.connecting {
                background-color: #f7b731;
                color: black;
            }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-container {
            background-color: #1a2633;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .video-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .video-title {
            font-size: 18px;
            font-weight: 600;
        }

        .video-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #2f3336;
        }

        video {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background-color: #000;
            min-height: 300px;
        }

        .debug-panel {
            background-color: #1a2633;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .debug-output {
            background-color: #0f1419;
            border: 1px solid #2f3336;
            border-radius: 6px;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }

        .debug-controls {
            margin-bottom: 10px;
        }

        .detection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .video-container {
            position: relative;
        }

        .detection-box {
            position: absolute;
            border: 2px solid #00ff00;
            background-color: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
            opacity: 1;
        }

        .detection-box.fading {
            opacity: 0;
        }

        .detection-label {
            position: absolute;
            top: -25px;
            left: 0;
            background-color: #00ff00;
            color: black;
            padding: 2px 6px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 3px;
        }

        .stats {
            margin-top: 10px;
            font-size: 12px;
            color: #8b98a5;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .stat-item {
            background-color: #2f3336;
            padding: 5px 10px;
            border-radius: 4px;
        }

        .notifications {
            background-color: #1a2633;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            max-height: 300px;
            overflow-y: auto;
        }

        .notification {
            background-color: #2f3336;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

            .notification.detection {
                border-left: 4px solid #00ba7c;
            }

            .notification.error {
                border-left: 4px solid #f91880;
            }

        .notification-time {
            font-size: 11px;
            color: #8b98a5;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            max-height: 90%;
        }

        .modal img {
            width: 100%;
            height: auto;
            border-radius: 8px;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 40px;
            color: white;
            font-size: 40px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎥 CCTV Stream Viewer - Test Client</h1>

        <div class="controls">
            <div class="control-group">
                <label>API URL:</label>
                <input type="text" id="apiUrl" value="https://localhost:44322" placeholder="https://localhost:44322">
            </div>
            <div class="control-group">
                <label>Auth Token:</label>
                <input type="text" id="authToken" placeholder="Bearer token (optional for test)">
            </div>
            <div class="control-group">
                <label>Camera:</label>
                <select id="cameraSelect">
                    <option value="">Select a camera...</option>
                </select>
                <button id="refreshCameras">Refresh</button>
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" disabled>Disconnect</button>
            </div>
            <div class="control-group">
                <label>Test Mode:</label>
                <button id="createTestStream">Create Test Stream</button>
                <button id="loadVideoFile">Load Video File</button>
                <input type="file" id="videoFileInput" accept="video/*" style="display: none;">
            </div>
            <div class="control-group">
                <label>AI Detection:</label>
                <span id="detectionStatus" style="margin-left: 10px; color: #00ba7c;">Auto-enabled</span>
            </div>
        </div>

        <div class="status disconnected" id="connectionStatus">
            Not Connected
        </div>

        <div class="debug-panel">
            <div class="debug-controls">
                <h3>Debug Console</h3>
                <button id="clearDebug">Clear</button>
                <button id="exportDebug">Export Logs</button>
            </div>
            <div class="debug-output" id="debugOutput"></div>
        </div>

        <div class="video-grid" id="videoGrid">
            <!-- Video streams will be added here dynamically -->
        </div>

        <div class="notifications">
            <h3>Notifications</h3>
            <div id="notificationList"></div>
        </div>
    </div>

    <!-- Modal for detection images -->
    <div id="imageModal" class="modal">
        <span class="close-modal">&times;</span>
        <div class="modal-content">
            <img id="modalImage" src="" alt="Detection">
        </div>
    </div>

    <!-- Include SignalR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.0/signalr.min.js"></script>

    <!-- Include TensorFlow.js for real-time person detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <script>

        let debugMessages = [];

        function debugLog(message, data = null) {
            const timestamp = new Date().toISOString();
            const logEntry = `[${timestamp}] ${message}`;
            if (data) {
                console.log(logEntry, data);
                debugMessages.push(logEntry + '\n' + JSON.stringify(data, null, 2));
            } else {
                console.log(logEntry);
                debugMessages.push(logEntry);
            }

            updateDebugOutput();
        }

        function updateDebugOutput() {
            const debugOutput = document.getElementById('debugOutput');
            debugOutput.textContent = debugMessages.slice(-100).join('\n\n');
            debugOutput.scrollTop = debugOutput.scrollHeight;
        }

        const config = {
            apiUrl: 'https://localhost:44322',
            authToken: '',
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        let signalRConnection = null;
        let peerConnections = {};
        let cameras = [];
        let currentCameraId = null;

        let detectionModel = null;
        let detectionEnabled = false;
        let detectionIntervals = {};
        let lastDetectionTime = {};
        let detectionDisplayTimeouts = {};
        let detectionStats = {
            totalDetections: 0,
            fps: 0,
            avgConfidence: 0
        };

        const apiUrlInput = document.getElementById('apiUrl');
        const authTokenInput = document.getElementById('authToken');
        const cameraSelect = document.getElementById('cameraSelect');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const connectionStatus = document.getElementById('connectionStatus');
        const videoGrid = document.getElementById('videoGrid');
        const notificationList = document.getElementById('notificationList');
        const createTestStreamBtn = document.getElementById('createTestStream');
        const loadVideoFileBtn = document.getElementById('loadVideoFile');
        const videoFileInput = document.getElementById('videoFileInput');
        const refreshCamerasBtn = document.getElementById('refreshCameras');

        const detectionStatusSpan = document.getElementById('detectionStatus');

        async function initialize() {
            debugLog('Initializing application');
            apiUrlInput.value = config.apiUrl;
            await loadCameras();

            connectBtn.addEventListener('click', connect);
            disconnectBtn.addEventListener('click', disconnect);
            createTestStreamBtn.addEventListener('click', createTestStream);
            loadVideoFileBtn.addEventListener('click', () => videoFileInput.click());
            videoFileInput.addEventListener('change', handleVideoFileSelect);
            refreshCamerasBtn.addEventListener('click', loadCameras);

            await initializeDetectionModel();

            document.getElementById('clearDebug').addEventListener('click', () => {
                debugMessages = [];
                updateDebugOutput();
            });

            document.getElementById('exportDebug').addEventListener('click', () => {
                const blob = new Blob([debugMessages.join('\n\n')], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cctv-debug-${new Date().toISOString()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            });

            const modal = document.getElementById('imageModal');
            const closeModal = document.querySelector('.close-modal');
            closeModal.addEventListener('click', () => modal.style.display = 'none');
            window.addEventListener('click', (e) => {
                if (e.target === modal) modal.style.display = 'none';
            });

            debugLog('Application initialized');
        }

        async function loadCameras() {
            try {
                debugLog('Loading cameras');
                const response = await fetch(`${apiUrlInput.value}/api/v1/stream/cameras`);
                if (!response.ok) throw new Error('Failed to load cameras');

                const data = await response.json();
                debugLog('API Response', data);

                cameras = data.result?.items || data.items || [];

                cameraSelect.innerHTML = '<option value="">Select a camera...</option>';
                cameras.forEach(camera => {
                    const option = document.createElement('option');
                    option.value = camera.id;
                    option.textContent = `${camera.name} (${camera.location})`;
                    cameraSelect.appendChild(option);
                });

                debugLog(`Loaded ${cameras.length} cameras`);
                addNotification('Loaded ' + cameras.length + ' cameras', 'info');
            } catch (error) {
                debugLog('Error loading cameras', error);
                addNotification('Failed to load cameras: ' + error.message, 'error');
            }
        }

        async function connect() {
            const cameraId = cameraSelect.value;
            if (!cameraId) {
                alert('Please select a camera');
                return;
            }

            try {
                debugLog('Starting connection process', { cameraId });
                updateStatus('connecting', 'Connecting...');

                signalRConnection = new signalR.HubConnectionBuilder()
                    .withUrl(`${apiUrlInput.value}/streamingHub`, {
                        accessTokenFactory: () => authTokenInput.value.replace('Bearer ', '')
                    })
                    .withAutomaticReconnect()
                    .build();

                signalRConnection.on('PersonDetected', handlePersonDetection);
                signalRConnection.on('AlertNotification', handleAlertNotification);

                await signalRConnection.start();
                debugLog('SignalR connected');

                currentCameraId = cameraId;
                debugLog('Requesting camera stream', { cameraId });
                const response = await signalRConnection.invoke('RequestCameraStream', cameraId);
                debugLog('Camera stream response', response);

                if (response.success) {
                    await setupWebRTC(cameraId, response.data);
                    updateStatus('connected', 'Connected');
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                } else {
                    throw new Error(response.error || 'Failed to request stream');
                }
            } catch (error) {
                debugLog('Connection error', error);
                updateStatus('disconnected', 'Connection failed: ' + error.message);
                addNotification('Connection failed: ' + error.message, 'error');
            }
        }

        async function setupWebRTC(cameraId, offer) {
            try {
                debugLog('Setting up WebRTC', { cameraId, offer });

                const container = createVideoContainer(cameraId);
                const video = container.querySelector('video');

                video.addEventListener('loadstart', () => debugLog('Video: loadstart event'));
                video.addEventListener('loadedmetadata', () => {
                    debugLog('Video: metadata loaded', {
                        videoWidth: video.videoWidth,
                        videoHeight: video.videoHeight,
                        duration: video.duration
                    });
                });
                video.addEventListener('loadeddata', () => debugLog('Video: data loaded'));
                video.addEventListener('canplay', () => debugLog('Video: can play'));
                video.addEventListener('canplaythrough', () => debugLog('Video: can play through'));
                video.addEventListener('playing', () => debugLog('Video: is playing'));
                video.addEventListener('play', () => debugLog('Video: play event'));
                video.addEventListener('pause', () => debugLog('Video: pause event'));
                video.addEventListener('waiting', () => debugLog('Video: waiting for data'));
                video.addEventListener('stalled', () => debugLog('Video: stalled'));
                video.addEventListener('suspend', () => debugLog('Video: suspend'));
                video.addEventListener('abort', () => debugLog('Video: abort'));
                video.addEventListener('error', (e) => {
                    debugLog('Video error', {
                        error: e.target.error,
                        code: e.target.error?.code,
                        message: e.target.error?.message
                    });
                });

                const pcConfig = {
                    iceServers: config.iceServers,
                    iceCandidatePoolSize: 10
                };
                const pc = new RTCPeerConnection(pcConfig);
                peerConnections[cameraId] = pc;

                debugLog('Peer connection created', pcConfig);

                pc.ontrack = (event) => {
                    debugLog('Received track event', {
                        track: event.track,
                        streams: event.streams,
                        kind: event.track.kind,
                        readyState: event.track.readyState,
                        enabled: event.track.enabled,
                        muted: event.track.muted
                    });

                    if (event.streams && event.streams.length > 0) {
                        const stream = event.streams[0];
                        debugLog('Setting video srcObject', {
                            streamId: stream.id,
                            tracks: stream.getTracks().map(t => ({
                                kind: t.kind,
                                id: t.id,
                                readyState: t.readyState,
                                enabled: t.enabled,
                                muted: t.muted
                            }))
                        });

                        video.srcObject = stream;

                        const playPromise = video.play();
                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                debugLog('Video started playing successfully');

                                if (detectionEnabled && detectionModel) {
                                    setTimeout(() => {
                                        if (video.videoWidth > 0 && video.videoHeight > 0) {
                                            startDetectionForVideo(video);
                                            debugLog('Started detection for video', { 
                                                width: video.videoWidth, 
                                                height: video.videoHeight 
                                            });
                                        }
                                    }, 2000);
                                }
                            }).catch(err => {
                                debugLog('Failed to play video', err);

                                if (err.name === 'NotAllowedError') {
                                    debugLog('Autoplay prevented, adding user interaction handler');
                                    const playButton = document.createElement('button');
                                    playButton.textContent = 'Click to Play Video';
                                    playButton.style.position = 'absolute';
                                    playButton.style.top = '50%';
                                    playButton.style.left = '50%';
                                    playButton.style.transform = 'translate(-50%, -50%)';
                                    playButton.style.zIndex = '1000';
                                    playButton.onclick = () => {
                                        video.play();
                                        playButton.remove();
                                    };
                                    container.appendChild(playButton);
                                }
                            });
                        }
                    } else {
                        debugLog('No streams in track event - this is unusual');
                    }
                };

                pc.onicecandidate = async (event) => {
                    if (event.candidate) {
                        debugLog('Sending ICE candidate', event.candidate);

                        const candidateData = {
                            candidate: event.candidate.candidate,
                            sdpMid: event.candidate.sdpMid,
                            sdpMLineIndex: event.candidate.sdpMLineIndex
                        };

                        try {
                            const result = await signalRConnection.invoke('SendIceCandidate', cameraId, candidateData);
                            debugLog('ICE candidate sent', result);
                        } catch (err) {
                            debugLog('Failed to send ICE candidate', err);
                        }
                    } else {
                        debugLog('ICE gathering complete');
                    }
                };

                pc.onconnectionstatechange = () => {
                    debugLog('Connection state changed', pc.connectionState);
                    updateVideoStatus(cameraId, pc.connectionState);

                    if (pc.connectionState === 'connected') {
                        debugLog('WebRTC connection established successfully');

                        const receivers = pc.getReceivers();
                        debugLog('Active receivers', receivers.map(r => ({
                            track: r.track ? {
                                kind: r.track.kind,
                                id: r.track.id,
                                readyState: r.track.readyState,
                                enabled: r.track.enabled,
                                muted: r.track.muted
                            } : null
                        })));
                    } else if (pc.connectionState === 'failed') {
                        debugLog('WebRTC connection failed');
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    debugLog('ICE connection state', pc.iceConnectionState);
                };

                pc.onicegatheringstatechange = () => {
                    debugLog('ICE gathering state', pc.iceGatheringState);
                };

                const dataChannel = pc.createDataChannel('debug', { ordered: true });
                dataChannel.onopen = () => debugLog('Data channel opened');
                dataChannel.onclose = () => debugLog('Data channel closed');
                dataChannel.onerror = (error) => debugLog('Data channel error', error);

                debugLog('Setting remote description');
                await pc.setRemoteDescription(offer);
                debugLog('Remote description set successfully');

                debugLog('Creating answer');
                const answer = await pc.createAnswer({
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false
                });
                debugLog('Answer created', answer);

                await pc.setLocalDescription(answer);
                debugLog('Local description set');

                const answerData = {
                    type: answer.type,
                    sdp: answer.sdp
                };

                debugLog('Sending answer to SignalR');
                const answerResponse = await signalRConnection.invoke('SendAnswer', cameraId, answerData);
                debugLog('Answer response', answerResponse);

                if (!answerResponse.success) {
                    throw new Error('Failed to send answer: ' + (answerResponse.error || 'Unknown error'));
                }

                startStatsMonitoring(cameraId, pc);

            } catch (error) {
                debugLog('WebRTC setup error', error);
                throw error;
            }
        }

        function createVideoContainer(cameraId) {
            const camera = cameras.find(c => c.id === cameraId);

            const container = document.createElement('div');
            container.className = 'video-container';
            container.id = `video-${cameraId}`;
            container.innerHTML = `
                    <div class="video-header">
                        <div class="video-title">${camera?.name || 'Camera'}</div>
                        <div class="video-status" id="status-${cameraId}">Connecting...</div>
                    </div>
                    <video autoplay playsinline muted controls></video>
                    <div class="detection-overlay" id="detections-${cameraId}"></div>
                    <div class="stats" id="stats-${cameraId}">
                        <div class="stat-item">FPS: <span id="fps-${cameraId}">0</span></div>
                        <div class="stat-item">Bitrate: <span id="bitrate-${cameraId}">0</span> kbps</div>
                        <div class="stat-item">Resolution: <span id="resolution-${cameraId}">-</span></div>
                    </div>
                `;

            videoGrid.appendChild(container);
            return container;
        }

        function updateVideoStatus(cameraId, state) {
            const statusEl = document.getElementById(`status-${cameraId}`);
            if (statusEl) {
                statusEl.textContent = state;
                statusEl.style.backgroundColor = state === 'connected' ? '#00ba7c' :
                    state === 'connecting' ? '#f7b731' : '#f91880';
            }
        }

        function startStatsMonitoring(cameraId, pc) {
            const statsInterval = setInterval(async () => {
                if (pc.connectionState === 'closed' || pc.connectionState === 'failed') {
                    clearInterval(statsInterval);
                    return;
                }

                try {
                    const stats = await pc.getStats();
                    let inboundVideoStats = null;
                    let allStats = {};

                    stats.forEach(report => {
                        allStats[report.type] = allStats[report.type] || [];
                        allStats[report.type].push(report);

                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            inboundVideoStats = report;
                        }
                    });

                    if (Object.keys(allStats).length > 0) {
                        debugLog('WebRTC Stats Summary', {
                            types: Object.keys(allStats),
                            inboundRtp: allStats['inbound-rtp']?.length || 0,
                            candidatePairs: allStats['candidate-pair']?.length || 0,
                            localCandidates: allStats['local-candidate']?.length || 0,
                            remoteCandidates: allStats['remote-candidate']?.length || 0
                        });
                    }

                    if (inboundVideoStats) {
                        debugLog('Video stats', {
                            bytesReceived: inboundVideoStats.bytesReceived,
                            packetsReceived: inboundVideoStats.packetsReceived,
                            framesDecoded: inboundVideoStats.framesDecoded,
                            framesDropped: inboundVideoStats.framesDropped,
                            frameWidth: inboundVideoStats.frameWidth,
                            frameHeight: inboundVideoStats.frameHeight,
                            framesPerSecond: inboundVideoStats.framesPerSecond
                        });

                        const fpsEl = document.getElementById(`fps-${cameraId}`);
                        const bitrateEl = document.getElementById(`bitrate-${cameraId}`);
                        const resolutionEl = document.getElementById(`resolution-${cameraId}`);

                        if (fpsEl && inboundVideoStats.framesPerSecond) {
                            fpsEl.textContent = Math.round(inboundVideoStats.framesPerSecond);
                        }

                        if (bitrateEl && inboundVideoStats.bytesReceived) {

                            const bitrate = Math.round(inboundVideoStats.bytesReceived * 8 / 1000);
                            bitrateEl.textContent = bitrate;
                        }

                        if (resolutionEl && inboundVideoStats.frameWidth && inboundVideoStats.frameHeight) {
                            resolutionEl.textContent = `${inboundVideoStats.frameWidth}x${inboundVideoStats.frameHeight}`;
                        }
                    } else {
                        debugLog('No inbound video stats available yet');
                    }
                } catch (err) {
                    debugLog('Error getting stats', err);
                }
            }, 5000);
        }

        function handlePersonDetection(event) {
            debugLog('Person detected', event);

            const time = new Date(event.timestamp).toLocaleTimeString();
            const notification = document.createElement('div');
            notification.className = 'notification detection';
            notification.innerHTML = `
                    <div>
                        <strong>Person Detected</strong> - ${event.cameraName}
                        <div class="notification-time">${time}</div>
                        <div>Detections: ${event.detections.length}</div>
                    </div>
                `;

            if (event.frameImageBase64) {
                const img = document.createElement('img');
                img.className = 'detection-image';
                img.src = 'data:image/jpeg;base64,' + event.frameImageBase64;
                img.onclick = () => showImageModal(img.src);
                notification.appendChild(img);
            }

            notificationList.insertBefore(notification, notificationList.firstChild);

            drawDetections(event.cameraId, event.detections);
        }

        function drawDetections(cameraId, detections) {
            const overlay = document.getElementById(`detections-${cameraId}`);
            if (!overlay) return;

            overlay.innerHTML = '';

            detections.forEach((detection, index) => {
                const box = document.createElement('div');
                box.className = 'detection-box';

                const video = document.querySelector(`#video-${cameraId} video`);
                if (video) {
                    const videoWidth = video.videoWidth;
                    const videoHeight = video.videoHeight;
                    const displayWidth = video.offsetWidth;
                    const displayHeight = video.offsetHeight;

                    const scaleX = displayWidth / videoWidth;
                    const scaleY = displayHeight / videoHeight;

                    const [x1, y1, x2, y2] = detection.bbox || detection.boundingBox;

                    box.style.left = (x1 * scaleX) + 'px';
                    box.style.top = (y1 * scaleY) + 'px';
                    box.style.width = ((x2 - x1) * scaleX) + 'px';
                    box.style.height = ((y2 - y1) * scaleY) + 'px';

                    const label = document.createElement('div');
                    label.className = 'detection-label';
                    label.textContent = `Person ${Math.round(detection.confidence * 100)}%`;
                    box.appendChild(label);

                    overlay.appendChild(box);
                }
            });

            setTimeout(() => {
                overlay.innerHTML = '';
            }, 3000);
        }

        function handleAlertNotification(alert) {
            debugLog('Alert notification', alert);
            addNotification(alert.message, 'detection');
        }

        async function disconnect() {
            try {
                debugLog('Starting disconnect process');

                for (const [cameraId, pc] of Object.entries(peerConnections)) {
                    debugLog('Closing peer connection', { cameraId });
                    pc.close();

                    const container = document.getElementById(`video-${cameraId}`);
                    if (container) container.remove();
                }
                peerConnections = {};

                if (signalRConnection && currentCameraId) {
                    debugLog('Stopping camera stream', { cameraId: currentCameraId });
                    await signalRConnection.invoke('StopCameraStream', currentCameraId);
                    await signalRConnection.stop();
                }

                updateStatus('disconnected', 'Disconnected');
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                currentCameraId = null;

                debugLog('Disconnect completed');

            } catch (error) {
                debugLog('Disconnect error', error);
            }
        }

        async function createTestStream() {
            try {
                debugLog('Creating test stream');
                const response = await fetch(`${apiUrlInput.value}/api/v1/stream/test/create-stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': authTokenInput.value
                    },
                    body: JSON.stringify({
                        name: 'Test Pattern Stream',
                        type: 'pattern'
                    })
                });

                if (!response.ok) throw new Error('Failed to create test stream');

                const data = await response.json();
                debugLog('Test stream created', data);
                addNotification('Test stream created successfully', 'info');
                await loadCameras();

            } catch (error) {
                debugLog('Error creating test stream', error);
                addNotification('Failed to create test stream: ' + error.message, 'error');
            }
        }

        async function handleVideoFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                debugLog('Processing video file', { name: file.name, size: file.size, type: file.type });

                const response = await fetch(`${apiUrlInput.value}/api/v1/stream/test/create-stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': authTokenInput.value
                    },
                    body: JSON.stringify({
                        name: `Video File Test - ${file.name}`,
                        type: 'pattern',
                        videoFilePath: file.name
                    })
                });

                if (!response.ok) throw new Error('Failed to create video test stream');

                const data = await response.json();
                debugLog('Video file stream created', data);
                addNotification(`Video file "${file.name}" added as test stream`, 'info');
                await loadCameras();

                event.target.value = '';

            } catch (error) {
                debugLog('Error processing video file', error);
                addNotification('Failed to process video file: ' + error.message, 'error');
            }
        }

        function updateStatus(state, message) {
            connectionStatus.textContent = message;
            connectionStatus.className = `status ${state}`;
            debugLog('Status updated', { state, message });
        }

        function addNotification(message, type = 'info') {
            debugLog('Notification', { message, type });

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                    <div>
                        <div>${message}</div>
                        <div class="notification-time">${new Date().toLocaleTimeString()}</div>
                    </div>
                `;

            notificationList.insertBefore(notification, notificationList.firstChild);

            while (notificationList.children.length > 50) {
                notificationList.removeChild(notificationList.lastChild);
            }
        }

        function showImageModal(src) {
            const modal = document.getElementById('imageModal');
            const modalImg = document.getElementById('modalImage');
            modal.style.display = 'block';
            modalImg.src = src;
        }

        async function initializeDetectionModel() {
            try {
                detectionStatusSpan.textContent = 'Loading model...';
                debugLog('Loading COCO-SSD detection model...');

                detectionModel = await cocoSsd.load({ base: 'lite_mobilenet_v2' });

                detectionEnabled = true;

                debugLog('COCO-SSD model loaded successfully');
                detectionStatusSpan.textContent = 'Active';
                detectionStatusSpan.style.color = '#00ba7c';
                return true;
            } catch (error) {
                debugLog('Error loading detection model', error);
                detectionStatusSpan.textContent = 'Failed';
                detectionStatusSpan.style.color = '#f91880';
                addNotification('Failed to load AI detection model: ' + error.message, 'error');
                return false;
            }
        }

        function startDetectionForAllVideos() {
            document.querySelectorAll('.video-container video').forEach(video => {
                if (video.srcObject && video.videoWidth > 0) {
                    startDetectionForVideo(video);
                }
            });
        }

        function stopDetectionForAllVideos() {
            Object.values(detectionIntervals).forEach(interval => clearInterval(interval));
            detectionIntervals = {};

            document.querySelectorAll('.detection-overlay').forEach(overlay => {
                overlay.innerHTML = '';
            });
        }

        function startDetectionForVideo(video) {
            const container = video.closest('.video-container');
            const cameraId = container.id.replace('video-', '');

            if (detectionIntervals[cameraId]) {
                clearInterval(detectionIntervals[cameraId]);
            }

            detectionIntervals[cameraId] = setInterval(async () => {
                await detectPersonsInVideo(video, cameraId);
            }, 1000); 
        }

        async function detectPersonsInVideo(video, cameraId) {
            if (!detectionModel || !detectionEnabled || video.videoWidth === 0) return;

            try {
                const startTime = performance.now();

                const predictions = await detectionModel.detect(video);

                const personDetections = predictions.filter(prediction => 
                    prediction.class === 'person' && prediction.score > 0.4
                );

                const endTime = performance.now();
                const detectionTime = endTime - startTime;

                detectionStats.fps = Math.round(1000 / detectionTime);
                if (personDetections.length > 0) {
                    detectionStats.totalDetections += personDetections.length;
                    detectionStats.avgConfidence = personDetections.reduce((sum, det) => sum + det.score, 0) / personDetections.length;
                }

                displayDetections(cameraId, personDetections);

                if (shouldSendDetectionEvent(cameraId, personDetections)) {
                    sendRealtimeDetectionEvent(cameraId, personDetections);
                }

            } catch (error) {
                debugLog('Detection error for camera ' + cameraId, error);
            }
        }

        function displayDetections(cameraId, detections) {
            const overlay = document.getElementById(`detections-${cameraId}`);
            const video = document.querySelector(`#video-${cameraId} video`);
            if (!overlay || !video || video.videoWidth === 0) return;

            if (detectionDisplayTimeouts[cameraId]) {
                clearTimeout(detectionDisplayTimeouts[cameraId]);
            }

            const existingBoxes = overlay.querySelectorAll('.detection-box');
            existingBoxes.forEach(box => box.classList.add('fading'));

            setTimeout(() => {
                overlay.innerHTML = '';

                if (detections.length === 0) return;

                const videoDisplayWidth = video.offsetWidth;
                const videoDisplayHeight = video.offsetHeight;
                const videoActualWidth = video.videoWidth;
                const videoActualHeight = video.videoHeight;

                const videoAspectRatio = videoActualWidth / videoActualHeight;
                const displayAspectRatio = videoDisplayWidth / videoDisplayHeight;

                let scaleX, scaleY, offsetX = 0, offsetY = 0;

                if (videoAspectRatio > displayAspectRatio) {

                    scaleX = videoDisplayWidth / videoActualWidth;
                    scaleY = scaleX;
                    offsetY = (videoDisplayHeight - (videoActualHeight * scaleY)) / 2;
                } else {

                    scaleY = videoDisplayHeight / videoActualHeight;
                    scaleX = scaleY;
                    offsetX = (videoDisplayWidth - (videoActualWidth * scaleX)) / 2;
                }

                detections.forEach((detection, index) => {
                    const [x, y, width, height] = detection.bbox;

                    const box = document.createElement('div');
                    box.className = 'detection-box';
                    box.style.position = 'absolute';
                    box.style.left = (x * scaleX + offsetX) + 'px';
                    box.style.top = (y * scaleY + offsetY) + 'px';
                    box.style.width = (width * scaleX) + 'px';
                    box.style.height = (height * scaleY) + 'px';
                    box.style.border = '3px solid #00ff00';
                    box.style.backgroundColor = 'rgba(0, 255, 0, 0.15)';
                    box.style.pointerEvents = 'none';
                    box.style.zIndex = '20';
                    box.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';

                    const label = document.createElement('div');
                    label.className = 'detection-label';
                    label.textContent = `Person ${Math.round(detection.score * 100)}%`;
                    label.style.position = 'absolute';
                    label.style.top = '-30px';
                    label.style.left = '0';
                    label.style.backgroundColor = '#00ff00';
                    label.style.color = 'black';
                    label.style.padding = '4px 8px';
                    label.style.fontSize = '12px';
                    label.style.fontWeight = 'bold';
                    label.style.borderRadius = '4px';
                    label.style.whiteSpace = 'nowrap';
                    label.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';

                    box.appendChild(label);
                    overlay.appendChild(box);
                });

                detectionDisplayTimeouts[cameraId] = setTimeout(() => {
                    const boxes = overlay.querySelectorAll('.detection-box');
                    boxes.forEach(box => box.classList.add('fading'));

                    setTimeout(() => {
                        if (overlay) overlay.innerHTML = '';
                    }, 300);
                }, 4000);

            }, 300); 
        }

        function shouldSendDetectionEvent(cameraId, detections) {
            if (detections.length === 0) return false;

            const currentTime = Date.now();
            const lastTime = lastDetectionTime[cameraId] || 0;

            if (currentTime - lastTime > 3000) {
                lastDetectionTime[cameraId] = currentTime;
                return true;
            }
            return false;
        }

        function sendRealtimeDetectionEvent(cameraId, detections) {
            const camera = cameras.find(c => c.id === cameraId);
            if (!camera) return;

            const event = {
                cameraId: cameraId,
                cameraName: camera.name,
                detections: detections.map(det => ({
                    confidence: det.score,
                    bbox: det.bbox,
                    class: det.class
                })),
                timestamp: new Date().toISOString(),
                source: 'realtime-browser'
            };

            const time = new Date().toLocaleTimeString();
            const notification = document.createElement('div');
            notification.className = 'notification detection';
            notification.innerHTML = `
                <div>
                    <strong>Person Detection</strong> - ${camera.name}
                    <div class="notification-time">${time}</div>
                    <div>${detections.length} person(s) detected (Avg: ${Math.round(detectionStats.avgConfidence * 100)}%)</div>
                </div>
            `;

            notificationList.insertBefore(notification, notificationList.firstChild);

            handlePersonDetection(event);

            debugLog('Real-time detection event', event);
        }

        window.addEventListener('load', initialize);

        window.addEventListener('beforeunload', () => {
            if (signalRConnection) {
                disconnect();
            }
        });
    </script>
</body>
</html>